import fs from 'fs';

/**
 * Convert SRT to ASS format with proper style definitions
 * This version is dependency-injected: caller provides dimensions and color converter.
 */
export function convertSRTtoASS(srtPath, style, videoWidth, videoHeight, colorToASS, words) {
  const assPath = srtPath.replace('.srt', '.ass');

  try {
    if (!fs.existsSync(srtPath)) {
      throw new Error(`SRT not found: ${srtPath}`);
    }

    const srtContent = fs.readFileSync(srtPath, 'utf-8');
    const srtBlocks = srtContent.split(/\n\n+/).filter(Boolean);

    const subtitles = [];

    for (const block of srtBlocks) {
      const lines = block.split('\n');
      if (lines.length >= 3) {
        const timeLine = lines[1];
        const text = lines.slice(2).join(' ').trim();

        // 00:00:01,000 --> 00:00:03,000
        const [start, end] = timeLine.split('-->').map(s => s.trim());

        const formatTime = (timeStr) => {
          const [hms, ms] = timeStr.split(',');
          const parts = hms.split(':');
          return `${parts[0]}:${parts[1]}:${parts[2]}.${ms.substring(0, 2)}`;
        };

        const timeToMs = (timeStr) => {
          const [hms, ms] = timeStr.split(',');
          const [h, m, s] = hms.split(':').map(Number);
          return (h * 3600 + m * 60 + s) * 1000 + parseInt(ms);
        };

        subtitles.push({
          start: formatTime(start),
          end: formatTime(end),
          startMs: timeToMs(start),
          endMs: timeToMs(end),
          text
        });
      }
    }

    // Determine alignment and margins
    let alignment, marginV;
    if (style.alignment === 5) {
      alignment = 5;
      marginV = 0;
    } else if (style.alignment === 8) {
      alignment = 8;
      marginV = style.marginV;
    } else {
      alignment = 2;
      marginV = style.marginV;
    }

    // Colors
    const primaryColor = colorToASS(style.fontColor);
    const outlineColor = colorToASS(style.outlineColor);
    
    // For karaoke effect, use gray as secondary color so words appear to "light up"
    // Otherwise both colors are the same (no visible effect)
    const secondaryColor = style.animationStyle === 'karaoke' 
      ? '&H00808080'  // Gray color for unsung words
      : primaryColor; // Same as primary for standard subtitles

    let assContent = `[Script Info]\n` +
      `Title: Generated by YT-Machine\n` +
      `ScriptType: v4.00+\n` +
      `PlayResX: ${videoWidth}\n` +
      `PlayResY: ${videoHeight}\n\n` +
      `[V4+ Styles]\n` +
      `Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n` +
      `Style: Default,${style.fontFamily},${style.fontSize},${primaryColor},${secondaryColor},${outlineColor},&H00000000,${style.bold ? -1 : 0},${style.italic ? -1 : 0},0,0,100,100,0,0,1,${style.outlineWidth},0,${alignment},0,0,${marginV},1\n\n` +
      `[Events]\n` +
      `Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n`;

    if (style.animationStyle === 'karaoke' && words && words.length > 0) {
      // Karaoke style with word-level timestamps
      console.log(`   🎤 Generating karaoke subtitles with ${words.length} word timestamps`);
      for (const sub of subtitles) {
        // Filter words that overlap with this subtitle's time range
        // Include words that start before subtitle ends AND end after subtitle starts
        // Add small buffer (50ms) to catch words at boundaries
        const subWords = words.filter(w => 
          w.start < sub.endMs + 50 && w.end > sub.startMs - 50
        );
        
        if (subWords.length > 0) {
          let line = '';
          for (let i = 0; i < subWords.length; i++) {
            const word = subWords[i];
            const nextWord = subWords[i + 1];
            // Duration in centiseconds (1/100th of a second)
            const duration = nextWord ? (nextWord.start - word.start) / 10 : (word.end - word.start) / 10;
            // Use \kf for fill effect (more visible than \k)
            line += `{\\kf${Math.round(duration)}}${word.text} `;
          }
          assContent += `Dialogue: 0,${sub.start},${sub.end},Default,,0,0,0,,${line.trim()}\n`;
        } else {
          // Fallback to full text if no words matched
          assContent += `Dialogue: 0,${sub.start},${sub.end},Default,,0,0,0,,${sub.text}\n`;
        }
      }
    } else {
      // Standard line-by-line subtitles
      for (const sub of subtitles) {
        assContent += `Dialogue: 0,${sub.start},${sub.end},Default,,0,0,0,,${sub.text}\n`;
      }
    }

    fs.writeFileSync(assPath, assContent, 'utf-8');

    if (!fs.existsSync(assPath)) {
      throw new Error('ASS file was not created');
    }

    return assPath;
  } catch (error) {
    console.error(`   ⚠️  Failed to convert SRT to ASS: ${error.message}`);
    console.error(`   ⚠️  Stack: ${error.stack}`);
    return null;
  }
}
